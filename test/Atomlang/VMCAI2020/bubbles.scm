; Multiple variations of Bubble sort.
; Inspired by http://parallelcomp.uw.hu/ch09lev1sec3.html and
(define (cas v i j)
  (let ((ei (vector-ref v i))
         (ej (vector-ref v j)))
    (if (> ei ej)
      (begin
        (vector-set! v i ej)
        (vector-set! v j ei)))))

(define (bubbles-classic vect)
  (let outer ((i (- (vector-length vect) 1)))
    (if (>= i 0)
      (let inner ((j 0))
        (if (< j i)
          (begin (cas vect j (+ j 1))
            (inner (+ j 1))))
        (outer (- i 1))))))

(define (bubbles-odd-even vect)
  (let* ((len (vector-length vect))
          (red (- (/ len 2) 1)))
    (let outer ((i 0))
      (if (<= i len)
        (begin (if (odd? i)
                 (let inner ((j 0))
                   (if (<= j red)
                     (begin (cas vect (* 2 j) (+ (* 2 j) 1))
                       (inner (+ j 1)))))
                 (let inner ((j 1))
                   (if (<= j red)
                     (begin (cas vect (- (* 2 j) 1) (* 2 j))
                       (inner (+ j 1))))))
          (outer (+ i 1)))))))

;(define atom list)
;(define read car)
;(define reset! set-car!)
;(define future (lambda (x) x))
;(define deref (lambda (x) x))
;(define (swap! x y)(set-car! x (y (car x))))

; Idea from https://www.dcc.fc.up.pt/~ricroc/aulas/1516/cp/apontamentos/slides_sorting.pdf (slide 11). Straighforward inefficient implementation.
(define (bubbles-parallel vect)
  (define statuses (make-vector (vector-length vect)))
  (define futures (make-vector (- (vector-length vect) 1)))
  (define (do-part id prv-at own-at)
    (reset! own-at id)
    (let loop ((cur (- (vector-length vect) 2)))
      (if (>= cur id)
        (if (>= (read prv-at) cur)
          (loop cur)
          (begin (cas vect cur (+ cur 1))
            (reset! own-at (- cur 1))
            (loop (- cur 1)))))))
  (let init ((i 0))
    (if (<= i (- (vector-length vect) 1))
      (begin (vector-set! statuses i (atom (- (vector-length vect) 1)))
        (init (+ i 1)))))
  (reset! (vector-ref statuses 0) -1)
  (let start ((i 0))
    (if (< i (- (vector-length vect) 1))
      (begin (vector-set! futures  i (future (do-part i (vector-ref statuses i) (vector-ref statuses (+ i 1)))))
        (start (+ i 1)))))
  (let finish ((i 0))
    (if (< i (- (vector-length vect) 1))
      (begin (deref (vector-ref futures i))
        (finish (+ i 1))))))

(define n1 (random 10))
(define n2 (random 10))
(define n3 (random 10))
(define n4 (- (random 10) 10))
(define n5 (- (random 10) 10))
(define n6 (- (random 10) 10))
(define u (vector n1 n2 n6))
(define v (vector n1 n2 n6))
(define w (vector n1 n2 n6))

(bubbles-classic u)
(bubbles-odd-even v)
(bubbles-parallel w)

(and (equal? u v)
  (equal? v w))
