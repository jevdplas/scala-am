#lang racket
(provide future)
(provide deref)
(provide atom)
(provide reset!)
(provide read)
(provide display-recorded)
(provide t/new-lock)
(provide t/acquire)
(provide t/release)

(define thread-return-values (make-hash)) ;; map thread -> value
(define thread-return-values-sem (make-semaphore 1))
(define (thread-set-return-value t v)
  (semaphore-wait thread-return-values-sem)
  ; (fprintf (current-error-port) "setting return value of ~a~n" t)
  (hash-set! thread-return-values t v)
  (semaphore-post thread-return-values-sem))
(define (thread-return-value t)
  (semaphore-wait thread-return-values-sem)
  (when (not (hash-has-key? thread-return-values t))
    (error (format "thread hasn't returned: ~a" t)))
  (let ((v (hash-ref thread-return-values t)))
    (semaphore-post thread-return-values-sem)
    v))

(define thread-names (make-hash (list (cons (current-thread) "main")))) ;; map thread -> name
(define (thread-set-name t v)
  (hash-set! thread-names t v))
(define (thread-name t)
  (when (not (hash-has-key? thread-names t))
    (error (format "thread has no name: ~a" t)))
  (hash-ref thread-names t))

(define (abstract x)
  (cond ((integer? x) 'Num)
        ((real? x) 'Num)
        ((string? x) 'Str)
        ((symbol? x) 'Sym)
;        ((boolean? x) 'Bool)
        ((thread? x) (if (hash-has-key? thread-names x) (string->symbol (thread-name x)) "???"))
        ((procedure? x) x)
        ((list? x) "\"#<list>\"")
        ((pair? x) "\"#<list>\"")
        ((vector? x) "\"#<vector>\"")
        (else x)))

(define recorded-hash (make-hash))
(define record-thread (thread (lambda ()
                                (let loop ()
                                  (let* ((recv (thread-receive))
                                         (prev (if (hash-has-key? recorded-hash (car recv)) (hash-ref recorded-hash (car recv)) (set))))
                                    (hash-set! recorded-hash (car recv) (set-add prev (cdr recv)))
                                    (loop))))))
(define (recorded-values) (hash-keys recorded-hash))
(define (recorded t)
  (list->set (set-map (if (hash-has-key? recorded-hash t) (hash-ref recorded-hash t) (set)) (lambda (x) (map force x)))))
(define (display-recorded)
  (sleep 0.5)
  (printf "RESULTS:~n")
  (map (lambda (k)
         (printf "~a~n" (list k (set->list (recorded k)))))
       (recorded-values))
  (void))

(define-syntax (future stx)
  (with-syntax [(exp (format "~a" stx))]
    (syntax-case stx ()
      [(future e)
       #'(letrec ((t (thread (lambda ()
                               (thread-set-name (current-thread) exp)
                               (let ((v e))
                                 (thread-set-return-value (current-thread) v))))))
           (thread-set-name t exp)
           (thread-send record-thread (list (thread-name (current-thread)) 'create exp))
           t)])))
(define (deref t)
  (thread-send record-thread (list (thread-name (current-thread)) 'join (thread-name t)))
  (thread-wait t)
  (sleep 0.01)
  (thread-return-value t))

(define atom-sem (make-semaphore 1)) ;; To make compare-and-set! atomic.
(define-syntax (atom stx)
  (with-syntax [(addr (format "~a.~a" (syntax-line (cadr (syntax->list stx))) (+ 1 (syntax-column (cadr (syntax->list stx))))))]
    (syntax-case stx ()
      [(atom val) #'(mcons val addr)])))
(define (reset! var val)
  (semaphore-wait atom-sem)
  (thread-send record-thread (list (thread-name (current-thread)) 'write (mcdr var) (delay (abstract val))))
  (set-mcar! var val)
  (semaphore-post atom-sem))
(define (read var)
  (let ((val (mcar var)))
    (thread-send record-thread (list (thread-name (current-thread)) 'read (mcdr var) (delay (abstract val))))
    val))
(define (compare-and-set! at old new)
  (semaphore-wait atom-sem)
  (let ((val (mcar at)))
    (thread-send record-thread (list (thread-name (current-thread)) 'read (mcdr at) (delay (abstract val))))
    (let ((res (if (eq? val old)
                   (begin (set-mcar! at new)
                          (thread-send record-thread (list (thread-name (current-thread)) 'write (mcdr at) (delay (abstract new))))
                          #t)
                   #f)))
      (semaphore-post atom-sem)
      res)))

(define (t/new-lock)
  (atom #f))
(define (t/acquire lock)
  (let try ()
    (if (compare-and-set! lock #f #t)
        #t
        (try))))
(define (t/release lock)
  (reset! lock #f))