#lang racket
(define (read-from-file file)
  (call-with-input-file file
    (lambda (in)
      (define result (make-hash))
      (define (loop)
        (let ((entry (read in)))
          (if (eof-object? entry)
              result
              (let ((key (car entry))
                    (value (cadr entry)))
                (hash-set! result key (set-union (if (hash-has-key? result key) (hash-ref result key) (set)) (list->set value)))
                (loop)))))
      (loop))))
(define (size results)
  (define size 0)
  (for-each (lambda (k)
              (set! size (+ size (set-count (hash-ref results k)))))
            (hash-keys results))
  size)
(define modular-results (read-from-file (vector-ref (current-command-line-arguments) 0)))
(define incremental-results (read-from-file (vector-ref (current-command-line-arguments) 1)))
(define match #t)
(when (not (equal? modular-results incremental-results))
  (define keys (hash-keys modular-results))
  (for-each
   (lambda (TID)
     (let ((mod (hash-ref modular-results TID (set)))
           (inc (hash-ref incremental-results TID (set))))
       (unless (set=? mod inc)
         (set! match #f)
         ; (printf "mismatch for actor ~a: ~a (conc.) vs. ~a (abs.) ~n" k c a)
         ; (printf "conc - abs = ~a~n" (set-subtract c a))
         (printf "[~a] overapproximates ~a element(s): ~a~n" TID (set-count (set-subtract inc mod)) (set-subtract inc mod))
         (unless (set-empty? (set-subtract mod inc))
           (printf "UNSOUND on Thread ~a ~a~n" TID (set-subtract mod inc))))))
   keys))
(printf "result: ~a, ~a concrete elements~n" match (size modular-results))
